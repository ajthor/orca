package builder

// "archive/tar"
// "io/ioutil"
// "compress/gzip"
//
// "github.com/docker/docker/pkg/progress"
// "github.com/docker/docker/pkg/streamformatter"
// "github.com/docker/docker/pkg/term"
// "github.com/docker/libcompose/logger"
import (
  "context"
  "io"
  "os"

  "io/ioutil"

  "github.com/docker/docker/api/types"
  "github.com/docker/docker/client"
  "github.com/docker/docker/pkg/archive"
	"github.com/docker/docker/pkg/jsonmessage"
	"github.com/docker/docker/pkg/term"
  log "github.com/gorobot/robologger"
)

// This may be generalized in the future to an interface that spans the entire
// library, but for now, it only handles the builder.
type builder interface {
  Build()
  CreateContext()
  Validate()
}

// The builder structure holds the information for our build context, and all
// of the options necessary for interfecing with the Docker API.
type Builder struct {
  Config *BuildOptions
  Client *client.Client
  // The directory holds the temporary directory where we copy the files to
  // create the build context. Any files that need to be included in the build
  // need to be specified in `includes`.
  Directory *string
  // The context holds the build context generated by the `CreateContext`
  // function. This is a tar file that is generated during runtime. If a
  // separate context is created and passed to the builder, it needs to be
  // compressed as a Gzip.
  Context io.ReadCloser
}

type BuildOptions struct {
  Base string
  Version string
  Hash string
  File string
  Mirror string
  URL string
  Dockerfile string
  // Includes holds any files besides the Dockerfile which need to be included
  // in the build context.
  Includes []string
  Tags []string
}

type ClientOptions struct {
  Host, Version string
}

func New(opts ClientOptions) *Builder {
  // "unix:///var/run/docker.sock"

  // We aren't using an http client, so the headers are dummy headers for now.
  defaultHeaders := map[string]string{
    "User-Agent": "engine-api-cli-1.0",
  }

  // Create a new connection to the Docker server.
  cli, err := client.NewClient(opts.Host, opts.Version, nil, defaultHeaders)
  if err != nil {
    log.Fatal(err)
  }

  return &Builder{
    Client: cli,
  }
}

func (b *Builder) Build(opts *BuildOptions) {
  // Before we do anything else, we need to validate the build using the
  // `Validate` function, specified in `validate.go`.
  err := b.Validate(opts)
  if err != nil {
    log.Fatal(err)
  }

  // If the validation passed, we pass the build options into the builder.
  b.Config = opts

  // Create the build context.
  log.Info("Creating build context...")

  err = b.CreateContext()
	if err != nil {
		log.Fatal(err)
	}

  // Make sure to close the tarfile when we're done.
  defer b.Context.Close()

  buildOptions := types.ImageBuildOptions{
    Tags: b.Config.Tags,
    Dockerfile: "Dockerfile",
  }

  // Once we have the build context, we can go through the process of building
  // the image. This is handles by the `ImageBuild` function.
  log.Info("Building image...")
  resp, err := b.Client.ImageBuild(context.Background(), b.Context, buildOptions)
  if err != nil {
		log.Fatal(err)
	}

  defer resp.Body.Close()

  // Print the Docker build info to the stream.
  outFd, isTerminalOut := term.GetFdInfo(os.Stdout)
  err = jsonmessage.DisplayJSONMessagesStream(resp.Body, os.Stdout, outFd, isTerminalOut, nil)
	if err != nil {
    log.Fatal(err)
	}

  // imgs, err := getImages(c)
  // for _, img := range imgs {
  //   log.Debugf(" --- %s", img)
  // }

}

// In the `CreateContext` function, we template the Dockerfile into a temporary
// directory created for the build context, and we copy any files that were
// specified as includes into the same directory. Once we have done that, we
// use Docker's archive tool to create a tarfile to serve as the build context.
func (b *Builder) CreateContext() error {
  // If there is no directory supplied to the builder, we create a temporary
  // directory for the build context.
  if b.Directory == nil {
    // Create a temporary directory. Default is /tmp/buildXXXXXXXXX
    dir, err := ioutil.TempDir("", "build")
  	if err != nil {
  		log.Fatal(err)
  	}

    log.Debugf("---> %s", dir)
    b.Directory = &dir
  }

  // Template the Dockerfile into the temporary directory.
  err := b.generateDockerfile()
  if err != nil {
    return err
  }

  // Copy in the include files.
  b.addContextFiles()

  // Create the build context tar file.
	b.Context, err = archive.Tar(*b.Directory, archive.Gzip)

  return nil
}
