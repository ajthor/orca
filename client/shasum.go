package client

import (
  "bufio"
  "fmt"
  "io"
  "os"
  "strings"

  "crypto/sha256"
  "net/http"
  "path/filepath"

  // "github.com/gorobot-library/orca/manifest"

  log "github.com/gorobot/robologger"
)

// GenerateShasums takes a manifest and generates shasums for the files and
// versions specified in the file.
func (c *Client) GenerateShasums(files, urls []string) ([]string, error) {
  log.Infof("Generating shasums...")

  // Create an empty slice to hold our generated shasums.
  hashes := make([]string, len(files))

  dir, err := c.makeTempDirectory("shasums")
  if err != nil {
    return hashes, err
  }

  for i, dlurl := range urls {
    dlfile := filepath.Join(dir, files[i])

    // Download the file to the temporary directory.
    err := c.DownloadFile(dlfile, dlurl)
    if err != nil {
      return hashes, err
    }

    log.Debugf("---> %s", dlfile)

    // Generate a hash for the downloaded file.
    hashes[i], err = c.CreateSha256(dlfile)
    if err != nil {
      return hashes, err
    }
  }

  return hashes, nil
}

// downloader wraps the io.ReadCloser returned from the http.Get function so
// that we can display a progress bar alongside the download. To accomplish
// this, we incorporate our own 'Read' and 'Close' methods for the ReadCloser
// interface.
type downloader struct {
  io.ReadCloser
  Total int64
  ContentLength int64
  Update func(int, interface{})
}

func (dl *downloader) Read(p []byte) (int, error) {
  n, err := dl.ReadCloser.Read(p)
  dl.Total += int64(n)

  if err == nil {
    dl.Update(int(100 * (float32(dl.Total) / float32(dl.ContentLength))), "downloading...")
  }

  return n, err
}

func (dl *downloader) Close() error {
  return dl.ReadCloser.Close()
}

// DownloadFile fetches the file from the
func (c *Client) DownloadFile(dlfile string, dlurl string) error {
  // Create a dummy file to copy the bytes to.
  out, err := os.Create(dlfile)
  if err != nil {
    return err
  }

  defer out.Close()

  log.Infof("Downloading %s...", dlurl)

  // Get the file from the download URL.
  r, err := http.Get(dlurl)
  if err != nil {
    return err
  }

  defer r.Body.Close()

  // If the response from the server is not 200 (OK), we have an error in the
  // file download and return an error.
  if r.StatusCode != 200 {
    return fmt.Errorf("Could not download %s [%d]", dlurl, r.StatusCode)
  }

  Update := log.Progress()

  dl := &downloader{
    ReadCloser: r.Body,
    ContentLength: r.ContentLength,
    Update: Update,
  }

  // Copy the file, byte by byte to the temporary file. This allows us to
  // download large files and not eat up memory.
  _, err = io.Copy(out, dl)
  if err != nil {
    return err
  }

  Update(100, "done")

  return nil
}

// CreateSha256 reads in the file specified as a parameter and generates a
// sha256 hash of the form: `shasum  file.tar.gz`
func (c *Client) CreateSha256(file string) (string, error) {
  f, err := os.Open(file)
  if err != nil {
    return "", err
  }

  defer f.Close()

  // Generate the hash.
  h := sha256.New()
  _, err = io.Copy(h, f)
  if err != nil {
    return "", err
  }

  // The hash line is a combination of the hash, two spaces, and the filename.
  shasum := fmt.Sprintf("%x", h.Sum(nil)) + "  " + filepath.Base(file)

  return shasum, nil
}

// GetSha256 takes the filename specified as a parameter and searches the
// SHASUM256.txt file for a matching filename. If one is found, it returns the
// entire line in the file.
func (c *Client) GetSha256(file string, match string) (string, error) {
  // Get all hashes from the shasum file.
  hashes, err := c.ReadShasumFile(file)
  if err != nil {
    return "", err
  }

  // Return a match if there is one.
  for _, h := range hashes {
    if contains := strings.Contains(h, match); contains {
      return h, nil
    }
  }

  return "", fmt.Errorf("Shasum not found.")
}

// ReadShasumFile reads in all of the hashes in the shasum file.
//
// Returns a string slice containing the hashes.
func (c *Client) ReadShasumFile(file string) ([]string, error) {
  hashes := []string{}

  // Make sure file exists.
  if _, err := os.Stat(file); os.IsNotExist(err) {
    return hashes, err
  }

  f, err := os.Open(file)
  if err != nil {
    return hashes, err
  }
  defer f.Close()

  // Create a new scanner to read the file line by line.
  scanner := bufio.NewScanner(f)
  for scanner.Scan() {
    // Append the lines to the output variable, hashes.
    hashes = append(hashes, scanner.Text())
  }

  // Check for errors in the scan.
  if err := scanner.Err(); err != nil {
    return hashes, err
  }

  return hashes, nil
}

// WriteShasumFile takes the hashes generated by the GenerateShasums function
// and outputs them to a file. Typically, the file is "SHASUM256.txt", located
// in the default directory. The shasum file will be overwritten if it already
// exists.
//
// If we want to ensure that the file is not overwritten, and that new hashes
// are only added to the file, it is safer to use AppendShasumFile instead.
//
// Returns an error if the file cannot be written.
func (c *Client) WriteShasumFile(file string, hashes []string) error {
  // Ensure the directory we are writing to exists and has the correct
  // permissions.
  c.makeDirectory(filepath.Dir(file))

  // Recreate the file.
  // f, err := os.OpenFile(file, os.O_RDWR|os.O_CREATE, 0644)
  f, err := os.Create(file)
  if err != nil {
    return err
  }

  defer f.Close()

  // And write the hashes to the file.
  w := bufio.NewWriter(f)
  defer w.Flush()

  for _, h := range hashes {
    _, err := w.WriteString(h + "\n")
    if err != nil {
      return err
    }
  }

  log.Debugf("---> %s", file)

  return nil
}

// AppendShasumFile takes hashes generated by the GenerateShasums function and
// appends them to the shasum file if they are not already present.
//
// If there is a chance that the shasum file already exists, or we do not want
// to take the cance of overwriting the shasum file, it is usually safer to
// call this function instead of WriteShasumFile.
func (c *Client) AppendShasumFile(file string, hashes []string) error {
  // Get all hashes from the shasum file.
  fileHashes, err := c.ReadShasumFile(file)
  if err != nil {
    // The file could not be read. We continue anyway, writing the hashes
    // supplied to a new file.
    return c.WriteShasumFile(file, hashes)
  }

  // We need to match the shasums based on the filenames. This way, we can
  // check if there is a duplicate that needs to be replaced in the file,
  // potentially updating the old shasum.
  fn := make([]string, len(fileHashes))

  // So we iterate over the hashes that were obtained from the file, in order
  // to determine which ones we need to include in the new hashes we are trying
  // to write.
  for i, fh := range fileHashes {
    // Store the filename of the old hash.
    f := strings.Split(fh, "  ")[1]
    fn[i] = f

    // Defined here for scope.
    var match bool

    // Now, we need to check if the filename of the old has is in the slice of
    // hashes we want to write. If it is not, we will include it in the hashes
    // to write to the file.
    for _, h := range hashes {
      // If the old filename is found in one of the new hashes, we have a match
      // and can stop looking. This hash will not be included in the file.
      if contains := strings.Contains(h, fn[i]); contains {
        match = true
        break
      }
    }

    // If there is no match, we include the old hash in the new hashes.
    if !match {
      hashes = append(hashes, fh)
    }
  }

  // Lastly, we write the file using the merged hashes.
  return c.WriteShasumFile(file, hashes)
}
