package client

import (
  "bufio"
  "errors"
  "os"
  "strings"

  "path/filepath"
)

var (
  ErrInvalidHash = errors.New("Invalid hash.")
)

// ShasumFile is a wrapper for an os.File that reads and writes entire lines of
// shasums to the file, rather than reading and writing slices of bytes.
type ShasumFile struct {
  file *os.File
  name string
}

// CreateShasumFile creates the shasum file at the location specified by `name`
// as if it were created using the os.Create function. The created file has
// os.O_RDWR permissions.
//
// Returns a pointer to a ShasumFile.
func CreateShasumFile(name string) (*ShasumFile, error) {
  file, err := os.OpenFile(name, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
  if err != nil {
    return nil, err
  }

  return &ShasumFile{
    file: file,
    name: name,
  }, nil
}

// OpenShasumFile opens the shasum file at the location specified by `name` as
// if it were opened using the os.Open function. The opened file has os.O_RDWR
// permissions.
//
// Returns a pointer to a ShasumFile.
func OpenShasumFile(name string) (*ShasumFile, error) {
  file, err := os.OpenFile(name, os.O_RDWR, 0)
  if err != nil {
    return nil, err
  }

  return &ShasumFile{
    file: file,
    name: name,
  }, nil
}

// Read reads in all of the hashes in the shasum file.
//
// Returns a string slice containing the hashes.
func (s *ShasumFile) Read() ([]*Shasum, error) {
  hashes := []*Shasum{}

  // Create a new scanner to read the file line by line.
  scanner := bufio.NewScanner(s.file)
  for scanner.Scan() {
    h, err := NewShasum(scanner.Text())
    // Check if the line that is read from the file is a valid hash. If it is,
    // we merge it with the hashes output from the function.
    if err == nil {
      hashes = append(hashes, h)
    }
  }

  // Check for errors in the scan.
  if err := scanner.Err(); err != nil {
    return hashes, err
  }

  return hashes, nil
}

// Write takes the hashes generated by the GenerateShasums function and outputs
// them to a file. Typically, the file is "SHASUM256.txt", located in the
// default directory. The shasum file will be overwritten if it already exists.
//
// If we want to ensure that the file is not overwritten, and that new hashes
// are only added to the file, it is safer to use Merge instead.
//
// Returns an error if the file cannot be written.
func (s *ShasumFile) Write(hashes []*Shasum) error {
  // Close the file so that we can recreate it.
  err := s.Close()
  if err != nil {
    return err
  }

  // Recreate the file. This clears the contents of the file.
  s.file = mustCreate(s.name)

  // And write the hashes to the file.
  w := bufio.NewWriter(s.file)
  defer w.Flush()

  for _, h := range hashes {
    _, err := w.WriteString(h.String() + "\n")
    if err != nil {
      return err
    }
  }

  return nil
}

// Merge takes hashes generated by the GenerateShasums function and merges them
// into the shasum file if they are not already present.
//
// If there is a chance that the shasum file already exists, or we do not want
// to take the cance of overwriting the shasum file, it is usually safer to
// call this function instead of Write.
func (s *ShasumFile) Merge(hashes []*Shasum) error {
  // Get all hashes from the shasum file.
  fileHashes, err := s.Read()
  if err != nil {
    // The file could not be read or is empty. We continue anyway, writing the
    // hashes supplied to a new file.
    return s.Write(hashes)
  }

  // We need to match the shasums based on the filenames. This way, we can
  // check if there is a duplicate that needs to be replaced in the file,
  // potentially updating the old shasum.
  // So we iterate over the hashes that were obtained from the file, in order
  // to determine which ones we need to include in the new hashes we are trying
  // to write.
  for _, fh := range fileHashes {
    // Defined here for scope.
    var match bool

    // Now, we need to check if the filename of the old has is in the slice of
    // hashes we want to write. If it is not, we will include it in the hashes
    // to write to the file.
    for _, h := range hashes {
      // If the old filename is found in one of the new hashes, we have a match
      // and can stop looking. This hash will *not* be included in the file.
      if contains := strings.Contains(h.String(), fh.File()); contains {
        match = true
        break
      }
    }

    // If there is no match, we include the old hash in the new hashes.
    if !match {
      hashes = append(hashes, fh)
    }
  }

  // Lastly, we write the file using the merged hashes.
  return s.Write(hashes)
}

// Close closes the ShasumFile when we are done with it.
func (s *ShasumFile) Close() error {
  return s.file.Close()
}

// FetchShasumFile fetches the SHASUM256.txt file at the specified url.
// The URL should point to a valid shasum file. For example:
// http://somewhere.com/SHASUM256.txt
//
// Returns a *ShasumFile
func (c *Client) FetchShasumFile(url string) (*ShasumFile, error) {
  dir := tempdir("", "fetch")

  destPath := filepath.Join(dir, "SHASUM256.txt")
  dest := mustCreate(destPath)
  defer dest.Close()

  // Download the file to the temporary directory.
  err := downloadFile(url, dest)
  if err != nil {
    return nil, err
  }

  return OpenShasumFile(destPath)
}
