package manifest

import (
  "bytes"
  "strings"

  "encoding/json"
  "html/template"
  "net/url"
  "path/filepath"

  // "github.com/gorobot-library/orca/config"
  // log "github.com/gorobot/robologger"

  "github.com/spf13/viper"
)

// Generated using: https://mholt.github.io/json-to-go/
type Remote struct {
  Mirror string `json:"mirror"`
  File string `json:"file"`
}

type Manifest struct {
  Name string `json:"name"`
  Repo string `json:"repo"`
  Registry string `json:"registry"`
  Dockerfile string `json:"dockerfile"`
  BaseImage string `json:"baseImage"`
  Files []string `json:"files"`
  Remote Remote `json:"remote"`
  Versions []string `json:"versions"`
  Platform struct {
    Architecture string `json:"architecture"`
    Os string `json:"os"`
  } `json:"platform"`
}

type ManifestSchema struct {
  Version int `json:"version"`
  Manifests []Manifest `json:"manifests"`
}

// NewSchema creates a new ManifestSchema that can be unmarshaled from a config
// file.
func NewSchema() *ManifestSchema {
  return &ManifestSchema{}
}

// Marshal wraps a json.Marshal call on the digest.
func (s *ManifestSchema) Marshal() ([]byte, error) {
  return json.Marshal(s)
}

// Unmarshal takes a viper config file and unmarshals the data into the
// ManifestSchema.
func (s *ManifestSchema) Unmarshal(cfg *viper.Viper) error {
  err := cfg.Unmarshal(s)
  if err != nil {
  	return err
  }

  return nil
}

// NewManifest creates a new, empty manifest.
func NewManifest() *Manifest {
  return &Manifest{}
}

// RemoteFilenames uses the Versions from the Manifest to template the
// filenames needed to both downlaod a file and save it.
func (m *Manifest) RemoteFilenames() []string {
  files := make([]string, len(m.Versions))

  type TemplateData struct {
    Version string
  }
  // Create the template.
  t := template.Must(template.New("").Parse(m.Remote.File))

  // Template the filenames using the version and save the output to the
  // 'files' variable.
  for i, v := range m.Versions {
    var tpl bytes.Buffer
    t.Execute(&tpl, &TemplateData{Version: v})
    files[i] = tpl.String()
  }

  return files
}

// RemoteURLs takes the file names that are generated by the RemoteFilenames
// function and appends the file name to the download mirror to create a full
// download URL.
func (m *Manifest) RemoteURLs() []string {
  files := m.RemoteFilenames()
  urls := make([]string, len(files))

  // Iterate over the files and append the file name to the mirror.
  for i, v := range files {
    u, _ := url.Parse(m.Remote.Mirror)
    u.Path = filepath.Join(u.Path, v)
    urls[i] = u.String()
  }

  return urls
}

// Tags returns the tags associated with the maniefest. It generates the tags
// using the registry, the repo, the image name, and the version.
func (m *Manifest) Tags(version string) []string {
  tags := []string{}

  if m.Repo != "" {
    s := []string{m.Repo, m.Name}
    tags = append(tags, strings.Join(s, "/"))
  }

  if m.Registry != "" {
    s := []string{m.Registry, m.Repo, m.Name}
    tags = append(tags, strings.Join(s, "/"))
  }

  // Generate the build tags.
  for i, t := range tags {
    s := []string{t, version}
    tags[i] = strings.Join(s, ":")
  }

  return tags
}
