/*
The Manifest package handles all manifest duties for the program.
*/

package manifest

import (
  "bytes"

  "html/template"
  "net/url"
  "path/filepath"

  "github.com/gorobot-library/orca/config"
  log "github.com/gorobot/robologger"
)

// Generated using: https://mholt.github.io/json-to-go/
type Remote struct {
  Mirror string `json:"mirror"`
  File string `json:"file"`
}

type Manifest struct {
  Name string `json:"name"`
  Repo string `json:"repo"`
  Registry string `json:"registry"`
  Dockerfile string `json:"dockerfile"`
  Files []string `json:"files"`
  Remote Remote `json:"remote"`
  Versions []string `json:"versions"`
  Platform struct {
    Architecture string `json:"architecture"`
    Os string `json:"os"`
  } `json:"platform"`
}

type ManifestSchema struct {
  Version int `json:"version"`
  Manifests []Manifest `json:"manifests"`
}

// type ManifestFileOptions struct {
//   // The path to the manifest file relative to the current directory.
//   Path string
// }

func New() *ManifestSchema {
  return &ManifestSchema{}
}

// Load looks for the manifest file, which can be specified in the options
// passed to the Manifest structure or be left as the default. It then looks
// for a file named manifest.xyz, where the type of the file can be any config
// compatible with Viper.
func Load(path string) *ManifestSchema {
  cfg, err := config.New(path)
  if err != nil {
    log.Fatal(err)
  }

  req := []string{
    "version",
    "manifests",
  }
  if err := config.HasRequired(cfg, req); err != nil {
    log.Fatal(err)
  }

  // manifests := cfg.Get("manifests").([]interface{})
  // log.Infof("%T", manifests)
  // log.Infof("%s", manifests[0].(map[string]interface{}))

  s := New()

  err = cfg.Unmarshal(s)
  if err != nil {
  	log.Fatalf("Unable to parse %s, %v", path, err)
  }

  return s
}

// GenerateFilenames uses the Versions from the Manifest to template the
// filenames needed to both save the downloaded file and to download it.
func (m *Manifest) GenerateFilenames() []string {
  files := make([]string, len(m.Versions))

  type TemplateData struct {
    Version string
  }

  // Create the template.
  t := template.Must(template.New("").Parse(m.Remote.File))

  // Template the filenames using the version and save the output to the
  // 'files' variable.
  for i, v := range m.Versions {
    var tpl bytes.Buffer
    t.Execute(&tpl, TemplateData{Version: v})
    files[i] = tpl.String()
  }

  return files
}

// GenerateURLs takes the file names that are generated by the
// GenerateFilenames function and appends the file name to the download mirror
// to create a full download URL.
func (m *Manifest) GenerateURLs(files []string) []string {
  urls := make([]string, len(files))

  // Iterate over the files and append the file name to the mirror.
  for i, v := range files {
    u, _ := url.Parse(m.Remote.Mirror)
    u.Path = filepath.Join(u.Path, v)
    urls[i] = u.String()
  }

  return urls
}
