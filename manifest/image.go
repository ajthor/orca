package manifest

import (
  "bytes"

  "html/template"
  "net/url"
  "path/filepath"

  "github.com/Masterminds/semver"
)

// Generated using: https://mholt.github.io/json-to-go/
type Remote struct {
  Mirror string `json:"mirror"`
  File string `json:"file"`
}

type Image struct {
  Name string `json:"name"`
  Dockerfile string `json:"dockerfile"`
  BaseImage string `json:"baseImage"`
  Files []string `json:"files"`
  Versions []string `json:"versions"`
  Remote Remote `json:"remote"`
}

// GetRemoteFile uses the Versions from the Manifest to template the filename
// needed to both download a file and save it.
func (img *Image) GetRemoteFile(version string) string {
  data := struct {
    Version string
  }{
    Version: version,
  }

  // Create the template.
  t := template.Must(template.New("").Parse(img.Remote.File))

  // Template the filename using the version and return the output.
  var tpl bytes.Buffer
  t.Execute(&tpl, data)
  return tpl.String()
}

// GetRemoteURL takes the file names that are generated by the
// GetRemoteFilename function and appends the file name to the download mirror
// to create a full download URL.
func (img *Image) GetRemoteURL(version string) string {
  file := img.GetRemoteFile(version)

  // Append the file name to the mirror.
  u, _ := url.Parse(img.Remote.Mirror)
  u.Path = filepath.Join(u.Path, file)
  return u.String()
}

// LatestVersion returns the latest version specified in the manifest.
func (img *Image) GetLatestVersion() string {
  latest := img.Versions[0]

  for _, v := range img.Versions {
    latestSemver := semver.MustParse(latest)
    nextSemver := semver.MustParse(v)
    if nextSemver.Compare(latestSemver) == 1 {
      latest = v
    }
  }

  return latest
}

// HasVersion checks the version from the flag passed to the command against
// the manifest. If no matching version is found, it returns false.
func (img *Image) HasVersion(version string) bool {
  for _, v := range img.Versions {
    if version == v {
      return true
    }
  }

  return false
}
